#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
require 'set'
require 'pathname'

#
# Damping factor (prob. of a 'random' jump)
# 0.85 works well in practice. See http://en.wikipedia.org/wiki/Pagerank
#
DAMPING_FACTOR = 0.85
N_ITERS = 10

# distribute pagerank among outbound links
def emit_pagerank_shares src, pagerank, dests
  outdegree      = dests.length
  pagerank_share = pagerank / outdegree
  dests.each do |dest|
    puts [dest, '1pr', pagerank_share].join("\t")
  end
end

# we need to dispatch the list of destination ids 
def emit_dest_ids src, dests
  puts [src, '2ids', dests.join(',')].join("\t")
end

# ***************************************************************************
#
# Parse map-phase inputs
# 

#
# Launch each relation towards each of its stakeholders,
# who will aggregate them in the +reduce+ phase
#
def pagerank_iteration_mapper
  $stdin.each do |line|
    line.chomp!
    src, pagerank, dests, *rest = line.split "\t"
    dests = dests.strip.split(',') if dests
    pagerank   = pagerank.to_f
    warn "Missing dests in line #{line}" if dests.nil?
    warn "Zero pagerank in line #{line}" if pagerank == 0.0
    # Recycle the list of destination ids
    emit_dest_ids src, dests
    # Emit pagerank shares
    emit_pagerank_shares src, pagerank, dests
  end
end


class AccumulatingReducer
  def self.accumulate last_key, key, vals
  end
  
  def emit
    check_accumulation_complete!
  end
  
  def check_accumulation_complete!
  end
end

class PagerankReducer < AccumulatingReducer
  attr_accessor :key, :pagerank, :dests
  def initialize key
    reset_state! key
  end
  # 
  def reset_state! key
    self.key      = key
    self.pagerank = 0.0
    self.dests    = nil    
  end
  
  def emit
    super
    damped_pagerank = (pagerank * DAMPING_FACTOR) + (1 - DAMPING_FACTOR)
    if !self.dests
      self.dests = 'dummy'
    end
    puts [key, damped_pagerank, self.dests].join("\t")
  end
  
  def collect src, what, vals
    val = vals.first
    case
    when what == '1pr'
      # ok we got some pagerank love
      self.pagerank += val.to_f
      # $stderr.puts("Got val #{[val, self].inspect}")
    when what == '2ids'
      # yay here's the list of destination ids
      self.dests = val
      # $stderr.puts("Got ids: #{[val, self].inspect}")
    else raise "Bad what '#{what}': #{[src, what, vals].inspect}"
    end
  end  
end

def pagerank_iteration_reducer
  last_key = nil; pagerank_reducer = PagerankReducer.new(nil)
  $stdin.each do |line|
    key, what, *vals = line.chomp.split "\t"; next if vals.empty?
    # accumulate all lines for given key
    last_key ||= key
    if last_key != key
      # Just saw last of previous key. dispatch it for output.
      pagerank_reducer.emit
      # Embark on a new pagerank accumulation
      last_key = key
      pagerank_reducer = PagerankReducer.new(key)
    end
    # grok the current line 
    pagerank_reducer.collect key, what, vals
  end
  pagerank_reducer.emit
end

def run_iterations
  slug = Time.now.strftime("%Y%m%d")
  input_dir, output_dir = ARGV[1..2]
  extra_args = "'"+(ARGV[3..-1]||[]).join("' '")+"'" unless ARGV[3..-1].empty?
  raise "You need to specify a pagerank file: got #{ARGV.inspect}" if input_dir.empty? || output_dir.empty?
  mapred_script = Pathname.new(__FILE__).realpath
  iter_in_dir = input_dir
  $stderr.puts "Launching hadoop streaming on self"
  (1..N_ITERS).each do |iter|
    iter_out_dir = "%s_%03d" % [output_dir, iter]
    puts %x{ hdp-stream #{iter_in_dir} #{iter_out_dir} '#{mapred_script} --map' '#{mapred_script} --reduce' 2 #{extra_args} }
    iter_in_dir  = iter_out_dir
  end  
end

case ARGV[0]
when '--map'    then pagerank_iteration_mapper
when '--reduce' then pagerank_iteration_reducer
when '--runme'  then 
  run_iterations
else raise %Q{ 
  Need to specify an argument: --run_me, --map or --reduce
  You probably want to say
    #{__FILE__} --runme pagerank_iteration_dir_prev pagerank_iteration_dir_new
  ... the first pagerank_iteration_dir should be generated by the gen_initial_pagerank script
}
end

# ./pagerank/gen_initial_pagerank_graph.rb --runme out/20081220-sorted-uff/a_replied_b.tsv  mid/20081220-pagerank_init
# ./pagerank/pagerank_iterate.rb --runme mid/20081220-pagerank_init mid/20081220-pagerank/

